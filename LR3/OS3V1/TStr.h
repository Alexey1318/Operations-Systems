#pragma once
#include <Windows.h>
#include <iostream>
#include <cstdlib>
class TStr{
private:
	static HANDLE hHeap;
	static UINT heapSize;
public:
	int n;
	int* mas[1023];

	void*operator new(size_t size) {
		//если кучи еще не существует 
		if (hHeap == NULL) {
			//создаем ее
			/*(модификатор способа выполнени€ операций над кучей,
			к-во байтов, изначально передаваемых куче
			максимальное к-во байтов - если передан нуль, система резервирует
			регион и, если надо, расшир€ет его до максимально возможного объема)*/
			hHeap = HeapCreate(0, 0, 0);
			//если неуспешное создание - метод не вернет описатель кучи, поэтому доп.проверка на успешность
			if (hHeap == NULL) {
				return NULL;
			}
		}
		//если описатель вернулс€ нормально, выдел€ем блок пам€ти из созданной кучи
		/*ѕараметр hHeap идентифицирует описатель кучи, из которой выдел€етс€ пам€ть. 
		ѕараметр fdwFlags позвол€ет указывать флаги, вли€ющие на характер выделени€ пам€ти - 0, потому что три других флага не подошли		
		ѕараметр dwBytes определ€ет число выдел€емых в куче байтов. */
		void* p = HeapAlloc(hHeap, 0, size);
		if (p != NULL) {
			heapSize++;
		}
		return p;
	}

	void operator delete(void * obj) {
		//освобождает блок пам€ти и при успешном вызове возвращает TRUE
		if (HeapFree(hHeap, 0, obj)) {
			heapSize--;
		}
		//уничтожаем всю кучу
		/*ќбращение к HeapDestroy приводит к освобождению всех блоков пам€ти
			внутри кучи и возврату системе физической пам€ти и зарезервированного региона
			адресного пространства, зан€тых кучей.ѕри успешном выполнении функци€ возвращает TRUE.*/
		if (heapSize == 0) {
			if (HeapDestroy(hHeap)) {
				hHeap = NULL;
			}
		}
	}
};
HANDLE TStr::hHeap = NULL;
UINT TStr::heapSize = 0;